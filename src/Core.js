(function (root) {
    "use strict";
    const Core = {};

    const isNodeJS = typeof require === 'function';
    const Executor = isNodeJS ? require('./Executor.js') : root.Executor;
    const Regex = isNodeJS ? require('./Regex.js') : root.Regex;
    const fs = isNodeJS ? require('fs') : undefined;

    /*  Returns a function witch on each call returns a number (radix 36, starting at zero). */
    function createIdGenerator(prefix = '') {
        let id = 0;
        return () => `${prefix}${(id++).toString(36)}`;
    }
    Core.createIdGenerator = createIdGenerator;

    Core.defaultEqual = (v1, v2) => v1 === v2;

    Core.defaultOnError = (message, error) => console.error(message, error);

    function getInvertedKeyValueObject(source, valueToKey) {
        const v2k = typeof valueToKey === 'function';
        const target = {};
        for (const s in source) {
            if (source.hasOwnProperty(s)) {
                target[v2k ? valueToKey(source[s]) : source[s]] = s;
            }
        }
        return target;
    }
    Core.getInvertedKeyValueObject = getInvertedKeyValueObject;

    /*  Kahn's algorithm  */
    function getTopologicalSorting(dependencies) {
        const graph = new Map();
        const inDegree = new Map();
        const queue = [];
        const result = [];
        for (const node in dependencies) {
            if (!inDegree.has(node))
                inDegree.set(node, 0);
            for (const dep of dependencies[node]) {
                graph.set(dep, (graph.get(dep) || []).concat(node));
                inDegree.set(node, (inDegree.get(node) || 0) + 1);
            }
        }
        for (const [node, degree] of inDegree.entries()) {
            if (degree === 0) queue.push(node);
        }
        while (queue.length > 0) {
            const node = queue.shift();
            result.push(node);
            for (const neighbor of graph.get(node) || []) {
                inDegree.set(neighbor, inDegree.get(neighbor) - 1);
                if (inDegree.get(neighbor) === 0) {
                    queue.push(neighbor);
                }
            }
        }
        if (result.length !== inDegree.size) {
            throw new Error("Cyclical dependency detected!");
        }
        return result;
    }
    Core.getTopologicalSorting = getTopologicalSorting;

    /*  Generates index.js */
    function generateIndexJs(name, components) {
        let txt = `// ${name}.js - generated by js_utils\n`;
        txt += `(function (root) {\n`;
        txt += `    "use strict";\n`;
        txt += `    const ${name} = {\n`;
        for (let i = 0; i < components.length; i++) {
            if (i > 0) {
                txt += `,\n`;
            }
            txt += `        ${components[i]}: require('./src/${components[i]}.js')`;
        }
        txt += `\n    };\n`;
        txt += `    Object.seal(${name});\n`;
        txt += `    module.exports = ${name};\n`;
        txt += `}(globalThis));\n`;
        return txt;
    }
    Core.generateIndexJs = generateIndexJs;

    /*  Helps writing new moduls*/
    function generateLibraryFileAccess(dependencies, scope = '@markus.hardardt/') {
        const components = getTopologicalSorting(dependencies);
        let txt = ``;
        // Code usable js_utils internal
        txt += `    // ### inside js_utils ###\n\n`;
        for (const file in dependencies) {
            if (dependencies.hasOwnProperty(file)) {
                txt += `    // ==> file: '${file}.js':\n`;
                txt += `    const ${file} = {};\n`;
                txt += `    // access to other components in node js and browser:\n`;
                txt += `    const isNodeJS = typeof require === 'function';\n`;
                const used = dependencies[file];
                for (let comp of components) {
                    if (used.indexOf(comp) >= 0) {
                        txt += `    const ${comp} = isNodeJS ? require('./${comp}.js') : root.${comp};\n`;
                    }
                }
                txt += `\n`;
            }
        }
        txt += `\n`;
        txt += `    // access js_utils components on node js:\n`;
        txt += `    // compact:\n`;
        txt += `    const {\n` 
        for (let i = 0; i < components.length; i++) {
            txt += `        ${components[i]}${(i < components.length - 1 ? ',' : '')} // direct access: const ${components[i]} = require('${scope}js_utils/src/${components[i]}.js');\n`;
        }
        txt += `    } = require('${scope}js_utils/js_utils.js');\n`;
        txt += `    // separated:\n`;
        for (let comp of components) {
            txt += `    const ${comp} = require('${scope}js_utils/src/${comp}.js');\n`;
        }
        txt += `\n`;
        txt += `    // js_utils files for browser provided by webserver:\n`;
        for (let comp of components) {
            txt += `    webServer.AddStaticFile('./node_modules/${scope}js_utils/src/${comp}.js');\n`;
        }
        return txt;
    }
    Core.generateLibraryFileAccess = generateLibraryFileAccess;

    /*  analyse js_utils library */
    function analyseLibrary(directory, output, index_js) {
        // TODO: Must be modified if file structure changed. This is a very simple solution so far
        const moduleNameRegex = /^([a-zA-Z][_a-zA-Z0-9]*)\.js$/;
        const moduleRegex = /\bconst\s+([a-zA-Z][_a-zA-Z0-9]*)\s*=\s*isNodeJS\s*\?\s*require\s*\(\s*'\.\/\1\.js'\s*\)\s*:\s*root\s*\.\s*\1\s*;/g;
        fs.readdir(directory, (error, files) => {
            if (error) {
                console.error(error);
                return;
            }
            const dependencies = {};
            for (let file of files) {
                const match = moduleNameRegex.exec(file);
                if (!match) {
                    continue;
                }
                const moduleName = match[1];
                dependencies[moduleName] = [];
                const text = fs.readFileSync(`${directory}/${file}`, 'utf8');
                Regex.each(moduleRegex, text, (start, end, match) => dependencies[moduleName].push(match[1]), true);
            }
            const topologicalSortedComponents = getTopologicalSorting(dependencies);
            const index = generateIndexJs('js_utils', topologicalSortedComponents);
            let txt = `/* analyse directory: ${directory} */\n\n`;
            txt += '/* js_utils dependencies */\n';
            txt += 'const dependencies = {\n';
            for (const m in dependencies) {
                if (dependencies.hasOwnProperty(m)) {
                    txt += `  '${m}': [${dependencies[m].map(e => `'${e}'`).join(', ')}],\n`;
                }
            }
            txt += '};\n\n';
            txt += '/* topological sorting */\n';
            txt += 'const topologicalSortedComponents = [\n';
            for (let i = 0; i < topologicalSortedComponents.length; i++) {
                if(i > 0) {
                    txt += ',\n';
                }
                txt += `   ${topologicalSortedComponents[i]}`;
            }
            txt += '\n];\n\n';
            txt += '/* source code samples */\n';
            txt += Core.generateLibraryFileAccess(dependencies);
            txt += `\n\n/* ${index_js} */\n`;
            txt += index;
            fs.writeFileSync(output, txt, 'utf8');
            if (index_js) {
                fs.writeFileSync(index_js, index, 'utf8');
            }
            console.log(`done (dumped: '${output}', exported: '${index_js}')`);
        });
    }
    Core.analyseLibrary = analyseLibrary;

    /*  Callack for all elements in the sources-array not found in the targets-array */
    function handleNotFound(sources, targets, equal, onNotFound, backward) {
        let sidx, slen = sources.length, tidx, tlen = targets.length;
        for (sidx = 0; sidx < slen; sidx++) {
            let source = backward === true ? sources[slen - 1 - sidx] : sources[sidx];
            let found = false;
            for (tidx = 0; tidx < tlen; tidx++) {
                if (typeof equal === 'function' ? equal(source, targets[tidx]) : source === targets[tidx]) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                try { // TODO: Do we need try/catch here?
                    onNotFound(source);
                }
                catch (error) {
                    console.error(`Failed calling onNotFound(source): ${error}`);
                }
            }
        }
    }
    Core.handleNotFound = handleNotFound;

    /*  Function and object interface validation */
    (function () {
        // This pattern matches valid javascript identifiers: [_$a-zA-Z][_$a-zA-Z0-9]*
        const attributeMethodRegex = /^\s*([_$a-zA-Z][_$a-zA-Z0-9]*)\s*\(\s*([_$a-zA-Z][_$a-zA-Z0-9]*(?:\s*,\s*[_$a-zA-Z][_$a-zA-Z0-9]*)*)?\s*\)\s*$/;
        const attributePropertyRegex = /^\s*([_$a-zA-Z][_$a-zA-Z0-9]*)\s*:\s*([_a-zA-Z0-9]+)\s*$/;
        const standardFunctionRegex = /^\s*function\s*\(\s*([_$a-zA-Z][_$a-zA-Z0-9]*(?:\s*,\s*[_$a-zA-Z][_$a-zA-Z0-9]*)*)?\s*\)/m;
        const lamdaFunctionRegex = /^\s*\(\s*([_$a-zA-Z][_$a-zA-Z0-9]*(?:\s*,\s*[_$a-zA-Z][_$a-zA-Z0-9]*)*)?\s*\)\s*=>/m;
        const lamdaFunctionSingleArgumentRegex = /^\s*([_$a-zA-Z][_$a-zA-Z0-9]*)\s*=>/m;
        const classMethodRegex = /^\s*([_$a-zA-Z][_$a-zA-Z0-9]*)\s*\(\s*([_$a-zA-Z][_$a-zA-Z0-9]*(?:\s*,\s*[_$a-zA-Z][_$a-zA-Z0-9]*)*)?\s*\)/m;
        const argumentRegex = /(?:\s*,\s*)?([_$a-zA-Z][_$a-zA-Z0-9]*)\s*/mg;
        function getArgumentsArray(argumentsSource) {
            const a = [];
            if (argumentsSource) {
                Regex.each(argumentRegex, argumentsSource, (start, end, match) => a.push(match[1]), true);
            }
            return a;
        }
        function validateArguments(argumentsSource, expectedArgumentsArray) {
            const actualArgumentsArray = getArgumentsArray(argumentsSource);
            if (expectedArgumentsArray.length !== actualArgumentsArray.length) {
                throw new Error(`invalid number of arguments (expected: ${expectedArgumentsArray.length}, actual: ${actualArgumentsArray.length})`);
            }
            for (let i = 0; i < expectedArgumentsArray.length; i++) {
                if (expectedArgumentsArray[i] !== actualArgumentsArray[i]) {
                    throw new Error(`invalid argument (${(i + 1)}) name (expected: '${expectedArgumentsArray[i]}', actual: '${actualArgumentsArray[i]}')`);
                }
            }
        }
        function validateFunction(functionInstance, expectedArguments, validateMethodArguments) {
            if (functionInstance === undefined) {
                throw new Error('is undefined!');
            } if (functionInstance === null) {
                throw new Error('is null');
            } else if (typeof functionInstance !== 'function') {
                throw new Error('is not a function');
            }
            if (validateMethodArguments !== true) {
                return;
            }
            const functionSource = functionInstance.toString();
            const expectedArgumentsArray = getArgumentsArray(expectedArguments);
            const standardFuncionMatch = standardFunctionRegex.exec(functionSource);
            if (standardFuncionMatch) {
                validateArguments(standardFuncionMatch[1], expectedArgumentsArray);
                return;
            }
            const lamdaFunctionMatch = lamdaFunctionRegex.exec(functionSource);
            if (lamdaFunctionMatch) {
                validateArguments(lamdaFunctionMatch[1], expectedArgumentsArray);
                return;
            }
            const lamdaFunctionSingleArgumentMatch = lamdaFunctionSingleArgumentRegex.exec(functionSource);
            if (lamdaFunctionSingleArgumentMatch) {
                validateArguments(lamdaFunctionSingleArgumentMatch[1], expectedArgumentsArray);
                return;
            }
            const classMethodMatch = classMethodRegex.exec(functionSource);
            if (classMethodMatch) {
                validateArguments(classMethodMatch[2], expectedArgumentsArray);
                return;
            }
            throw new Error(`has no arguments: '${functionSource}'`);
        }
        Core.validateFunction = validateFunction;

        function validateInterface(instanceType, objectInstance, expectedItems, validateMethodArguments) {
            if (objectInstance === undefined) {
                throw new Error(`${instanceType} is undefined!`);
            } if (objectInstance === null) {
                throw new Error(`${instanceType} is null`);
            } else if (typeof objectInstance !== 'object') {
                throw new Error(`${instanceType} is not an object`);
            } else if (Array.isArray(expectedItems)) {
                for (const expectedItem of expectedItems) {
                    const methodMatch = attributeMethodRegex.exec(expectedItem);
                    if (methodMatch) {
                        const methodName = methodMatch[1];
                        try {
                            validateFunction(objectInstance[methodName], methodMatch[2], validateMethodArguments)
                        } catch (error) {
                            throw new Error(`${instanceType} method '${methodName}' ${error.message}`);
                        }
                        continue;
                    }
                    const propertyMatch = attributePropertyRegex.exec(expectedItem);
                    if (propertyMatch) {
                        const propertyName = propertyMatch[1];
                        const expectedType = propertyMatch[2];
                        const actualPropertyValue = objectInstance[propertyName];
                        if (actualPropertyValue === undefined) {
                            throw new Error(`${instanceType} has no property '${propertyName}'`);
                        } else if (typeof actualPropertyValue !== expectedType) {
                            throw new Error(`${instanceType} property '${propertyName}' has invalid type (expected: '${expectedType}', actual: '${(typeof actualPropertyValue)}')`);
                        }
                        continue;
                    }
                    throw new Error(`Invalid method/property check pattern: '${expectedItem}'`);
                }
            }
        }
        Core.validateInterface = validateInterface;

        // Perform some tests
        const tasks = [];
        tasks.push((onSuccess, onError) => {
            try {
                const testAttributes = [
                    'Foo()',
                    'Baz(a)',
                    'Bar(b,c)',
                    'State:boolean',
                    'Answer:number',
                    'Text:string'
                ];
                validateInterface('Test1', {
                    Foo: function () { },
                    Baz: function (a) { },
                    Bar: function (b, c) { }, // b, c
                    State: true,
                    Answer: 42,
                    Text: 'Hello world'
                }, testAttributes, true);
                validateInterface('Test2', {
                    Foo: () => { },
                    Baz: a => { },
                    Bar: (b, c) => { },
                    State: true,
                    Answer: 42,
                    Text: 'Hello world'
                }, testAttributes, true);
                onSuccess();
            } catch (error) {
                onError(error);
            }
        });
        tasks.push((onSuccess, onError) => {
            try {
                validateInterface('Test3', {
                    Foo: arg => { }
                }, [
                    'Foo(arg)'
                ], true);
                onSuccess();
            } catch (error) {
                onError(error);
            }
        });
        // TODO: Add tests for each check
        Executor.run(tasks, () => console.log('validateInterface() tested successfully'), error => {
            throw new Error(error);
        });
    }());

    Object.freeze(Core);
    if (isNodeJS) {
        module.exports = Core;
    } else {
        root.Core = Core;
    }
}(globalThis));
