(function (root) {
    "use strict";
    const Helper = {};
    const isNodeJS = typeof require === 'function';
    const fs = isNodeJS ? require('fs') : undefined;
    const Regex = isNodeJS ? require('../src/Regex.js') : undefined;

    // TODO: Must be modified if file structure changed. This is a very simple solution so far
    const moduleNameRegex = /^([a-zA-Z][_a-zA-Z0-9]*)\.js$/;
    const moduleRegex = /\bconst\s+([a-zA-Z][_a-zA-Z0-9]*)\s*=\s*isNodeJS\s*\?\s*require\s*\(\s*'\.\/\1\.js'\s*\)\s*:\s*root\s*\.\s*\1\s*;/g;

    function loadDependencies(directory, ignorables, onSuccess, onError) {
        fs.readdir(directory, (error, files) => {
            if (error) {
                onError(error);
                return;
            }
            const dependencies = {};
            for (let file of files) {
                const match = moduleNameRegex.exec(file);
                if (!match) {
                    continue;
                }
                const moduleName = match[1];
                if (ignorables.indexOf(moduleName) >= 0) {
                    continue;
                }
                dependencies[moduleName] = [];
                const text = fs.readFileSync(`${directory}/${file}`, 'utf8');
                Regex.each(moduleRegex, text, (start, end, match) => dependencies[moduleName].push(match[1]), true);
            }
            onSuccess(dependencies);
        });
    }
    Helper.loadDependencies = loadDependencies;

    function formatDependencies(dependencies) {
        let txt = '';
        txt += 'const dependencies = {\n';
        for (const m in dependencies) {
            if (dependencies.hasOwnProperty(m)) {
                txt += `  '${m}': [${dependencies[m].map(e => `'${e}'`).join(', ')}],\n`;
            }
        }
        txt += '};\n';
        return txt;
    }
    Helper.formatDependencies = formatDependencies;

    const addStaticWebServerFilesFunctionName = 'addStaticWebServerJsUtilsFiles';

    const extRegex = /\/([_a-zA-Z][_a-zA-Z0-9\.]*)\.js$/;
    /*  Generates index.js */
    function generateIndexJs(name, scope, components, browserIgnorables, ext) {
        let txt = `// ${name}.js - generated by js_utils\n`;
        txt += `(function (root) {\n`;
        txt += `    "use strict";\n`;

        txt += `    function ${addStaticWebServerFilesFunctionName}(server) {\n`;
        for (let component of components) {
            if (browserIgnorables.indexOf(component) < 0) {
                txt += `        server.AddStaticFile('./node_modules/${scope}js_utils/src/${component}.js');\n`;
            }
        }
        if (Array.isArray(ext)) {
            for (let e of ext) {
                txt += `        server.AddStaticFile('./node_modules/${scope}js_utils/${e}'); // external\n`;
            }
        }
        txt += `    }\n`;
        txt += `    const ${name} = {\n`;
        for (let component of components) {
            txt += `        ${component}: require('./src/${component}.js'),\n`;
        }
        if (Array.isArray(ext)) {
            for (let e of ext) {
                const match = extRegex.exec(e);
                if (match) {
                    txt += `        ${match[1]}: require('./${e}'), // external\n`;
                }
            }
        }
        txt += `        ${addStaticWebServerFilesFunctionName}\n`;
        txt += `    };\n`;
        txt += `    Object.seal(${name});\n`;
        txt += `    module.exports = ${name};\n`;
        txt += `}(globalThis));\n`;
        return txt;
    }
    Helper.generateIndexJs = generateIndexJs;

    function generateInternalImports(dependencies, components) {
        let txt = ``;
        txt += `    // ### inside js_utils ###\n\n`;
        for (const file in dependencies) {
            if (dependencies.hasOwnProperty(file)) {
                txt += `    // file: '${file}.js':\n`;
                txt += `    const ${file} = {};\n`;
                txt += `    const isNodeJS = typeof require === 'function';\n`;
                const used = dependencies[file];
                for (let component of components) {
                    if (used.indexOf(component) >= 0) {
                        txt += `    const ${component} = isNodeJS ? require('./${component}.js') : root.${component};\n`;
                    }
                }
                txt += `\n`;
            }
        }
        return txt;
    }
    Helper.generateInternalImports = generateInternalImports;

    function generateExternalImports(scope, components, ext) {
        let txt = ``;
        txt += `    // access js_utils components on node js:\n`;
        txt += `    // compact:\n`;
        txt += `    const {\n`
        for (let component of components) {
            txt += `        ${component}, // direct access: const ${component} = require('${scope}js_utils/src/${component}.js');\n`;
        }
        if (Array.isArray(ext)) {
            for (let e of ext) {
                const match = extRegex.exec(e);
                if (match) {
                    txt += `        ${match[1]}, // direct access: const ${match[1]} = require('${scope}js_utils/${e}'); // external\n`;
                }
            }
        }
        txt += `        ${addStaticWebServerFilesFunctionName}\n`;
        txt += `    } = require('${scope}js_utils/js_utils.js');\n`;
        txt += `    // separated:\n`;
        for (let component of components) {
            txt += `    const ${component} = require('${scope}js_utils/src/${component}.js');\n`;
        }
        if (Array.isArray(ext)) {
            for (let e of ext) {
                const match = extRegex.exec(e);
                if (match) {
                    txt += `    const ${match[1]} = require('${scope}js_utils/${e}');\n`;
                }
            }
        }
        return txt;
    }
    Helper.generateExternalImports = generateExternalImports;

    function formatTopologicalSortedComponents(components) {
        let txt = '';
        txt += '/* topological sorting */\n';
        txt += 'const topologicalSortedComponents = [\n';
        for (let i = 0; i < components.length; i++) {
            if (i > 0) {
                txt += ',\n';
            }
            txt += `   '${components[i]}'`;
        }
        txt += '\n];\n';
        return txt;
    }
    Helper.formatTopologicalSortedComponents = formatTopologicalSortedComponents;

    Object.freeze(Helper);
    if (isNodeJS) {
        module.exports = Helper;
    } else {
        root.Helper = Helper;
    }
}(globalThis));
